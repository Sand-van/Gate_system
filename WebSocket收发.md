[参考文章](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_a_WebSocket_server_in_Java)

## 1 客户端 --> 服务端

```
GET / HTTP/1.1
Connection: Upgrade
Host: 127.0.0.1:8080
Sec-WebSocket-Key: WJl2syoK6hsxnCC=tfnvhgdd
Sec-WebSocket-Version: 13
Upgrade: websocket
```

(注意，结尾有两个换行，Host到时候要改)

## 2 客户端 <-- 服务端

```
HTTP/1.1 101 
Upgrade: websocket
Connection: upgrade
Sec-WebSocket-Accept: l5gTRTPY2MZMnZOE3v8JL/DzURk=(#to count)
Date: Mon, 30 Jan 2023 10:07:37 GMT \r\n\r\n
```

这里的Sec-WebSocket-Accept:是

**此时，http协议已经升级到了websocket协议**

<br/>

## 编解码

首先，我们要明确数据帧的格式：

```
      0                   1                   2                   3
      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     +-+-+-+-+-------+-+-------------+-------------------------------+
     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |
     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
     |N|V|V|V|       |S|             |   (if payload len==126/127)   |
     | |1|2|3|       |K|             |                               |
     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
     |     Extended payload length continued, if payload len == 127  |
     + - - - - - - - - - - - - - - - +-------------------------------+
     |                               |Masking-key, if MASK set to 1  |
     +-------------------------------+-------------------------------+
     | Masking-key (continued)       |          Payload Data         |
     +-------------------------------- - - - - - - - - - - - - - - - +
     :                     Payload Data continued ...                :
     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     |                     Payload Data continued ...                |
     +---------------------------------------------------------------+
```

<br/>

- FIN 位告诉我们这是不是系列的最后一条消息。如果是 0，那么服务器将继续侦听消息的更多部分；如果是1，则服务器应该处理信息
- RSV 位可以忽略，它们是用于标识是否启用扩展功能
- opcode 即操作码，其定义了如何解释有效负载数据：0x00 表示延续，0x01 表示文本 (总是用 UTF-8 编码)，0x02 表示二进制  **<u>（需要研究使用0x01还是0x02）</u>**
- MASK 即是否使用掩码，1为启用，0为不使用
- Payload len为数据长度，这部分比较复杂，在项目中我们只考虑数据长度小于126字节的情况
- Extended payload length 由于我们的数据长度小于126，这部分忽略
- Maksing-key 掩码值，有4个字节，代表着4个不同的掩码，将会下面的传输数据做运算来解密。如果不启用，则这部分忽略
- Payload Data 如果启用掩码，则这部分是被掩码加密的，如果没有启用掩码，则是原始数据。

***

### 编码

#### 客户端

1. 因为我们一次发完所有数据，且数据类型为二进制码，FIN 为1，RSV为000，opcode为0002，所以第一个字节固定为0x82
2. 客户端发给服务端需要启用掩码，即MASK为1，payload len为数据长度，所以第二个字节为 len + 0x80
3. 由于设置了启用掩码，那么第三、四、五、六个字节都是对应的掩码，这个是客户端自己设置的，可以随意取
4. 之后是具体数据，具体数据要和掩码加密，具体的加密方式为：数据和掩码循环异或，比如：data[0] 和 mask[0]异或，data[1] 和 mask[1]异或，以此类推，data[4] 和 mask[0] 异或，等待。

<br/>

一个具体的例子是，比如客户端要发送“abcdef”，那经过编码后的数据为[129, 134, 167, 225, 225, 210, 198, 131, 130, 182, 194, 135]

<br/>

#### 服务端

服务端与客户端有所不同的是，服务端向客户端发送数据时，不需要启用掩码

1. FIN 为1，RSV为000，opcode为0001，所以第一个字节固定为0x81
2. MASK 为0， 剩下的为数据长度
3. 没有启用掩码，则掩码部分忽略，直接为具体数据

***

### 解码

#### 客户端

客户端收到的是未加密的数据，则照常解码即可，舍弃第一字节，第二字节为数据长度，其后为未加密的数据

<br/>

#### 服务端

服务端收到的是加密的数据，先舍弃第一字节，将第二字节减去128（即最高位置0）后即为数据长度，获取3-6字节作为掩码，随后的数据则按照加密的过程逆向解密即可（注意到一个数异或两次后还是它本身，即A ^ B ^ B = A）
